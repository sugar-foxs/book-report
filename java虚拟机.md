# 深入理解java虚拟机
## 1. 内存分布
	首先了解下java虚拟机的内存分布，主要分为：程序计数器，虚拟机栈，本地方法栈，堆，方法区。
### 1> 程序计数器 <font color="#dd0000">(线程私有)</font>
	线程私有，即每个线程都会有一个，线程之间互不影响，独立存储。代表着当前线程所执行字节码的行号指示器。
### 2> 虚拟机栈 <font color="#dd0000">(线程私有)</font>
	1, 虚拟机栈其生命周期和线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。
	2, 局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表的容量以变量槽slot为最小单位，每个slot都能够存放基础类型数据，reference或returnAddress类型的数据。
	3, java程序使用对象就是使用reference类型的数据来操作堆上的对象。但是reference类型在虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位，访问堆中的对象的具体位置。所以对象访问方式取决于虚拟机的实现，目前主流的实现是使用句柄和直接指针两种方式。
	4, 如果使用句柄的话，堆中会划分一块内存来作为句柄池，reference中存储的是对象的句柄地址，句柄中则包含了对象实例数据和类型数据各自的具体地址信息。
	5, 使用直接指针的话，reference中存储的就是对象地址。
### 3> 本地方法栈 <font color="#dd0000">(线程私有)</font>
	本地方法栈和虚拟机栈发挥的作用是相似的，只不过虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机用到的Native方法服务。
### 4> 堆 <font color="#dd0000">(线程共享)</font>
	堆用来存放对象实例，也是垃圾回收的主要区域。
### 5> 方法区（非堆）<font color="#dd0000">(线程共享)</font>
	方法区用来存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。该区域的内存回收目标主要是针对常量池的回收和对类型的卸载。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容会在类加载后进入方法区的运行时常量池存放。
### 参数：-Xss 最大栈空间参数，如果不足会引起java.lang.StackOverflowError的异常。
### 堆的内存由-Xms指定，默认是物理内存的1/64；最大的内存由-Xmx指定，默认是物理内存的1/4。
## 2. jvm内存模型

## 3. 类加载机制

## 4. 垃圾回收算法
### 首先考虑哪些内存是可以做作为垃圾回收的。
### 1> 哪些内存需要回收？
	判定哪些对象需要回收，对象存活判定算法有两种：
	1，引用计数算法：给对象添加一个引用计数器，对象每被引用一次，引用计数器值就加一，引用失效减一，任何时刻当计数值为0的对象就是不能再被使用的。这个方法有循环引用的问题,不采用。
	2，可达性分析算法：对象和GC Roots之间有引用链时便是可达的，当不可达时，对象便可被回收。

### 2> 现在的垃圾回收器中一般都使用的是可达性分析算法，其中可作为GC Roots的对象有：
	1，虚拟机栈中引用的对象
	2，本地方法栈JNI引用的对象
	3，方法区中常量引用的对象
	4，方法区中类静态属性引用的对象

### 3> 如何进行垃圾回收？
####有四种垃圾回收算法：
	1，标记--清除算法：先标记然后统一回收，但是会产生大量内存碎片。
	2，复制算法：
	80%的Eden,两个10%的Survivor，对象存放在Eden和一个Survivor区中，当发生MinorGC后仍然存活的对象需要复制到另一个Survivor区中,此时这个S区和E区作为存放对象的地方。如果Survivor区无法容纳存活的对象，则需要老年代进行分配担保，直接进入老年代。前提是老年代本身得有容纳那些对象的空间，一共有多少对象存活下来再实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均值作为经验值，来决定是否进行Full GC来让老年代腾出更多空间。
	取平均值的方法不是一个100%可用的方法，如果对象突增，远远高于平均值，就会导致担保失败。但是担保失败后还是会重新发起一次Full GC。
	3，标记--整理算法：
	复制算法在对象存活率很高的时候，效率很低。所以老年代采用标记整理算法：先标记，然后让所有存活的对象往一端移动，直接清理掉端边界以外的内存。
	4，分代收集算法：
	将java堆分为新生代和老年代，新生代使用复制算法，老年代使用标记--清除或标记--整理算法。